# GTPlanner å®Œæ•´ç³»ç»Ÿæ¶æ„è®¾è®¡æ–‡æ¡£

åŸºäºè®¾è®¡æ¨¡å¼åŸåˆ™å’Œç°æœ‰ä»£ç åˆ†æï¼Œä¸ºGTPlannerè®¾è®¡ä¸€ä¸ªæ¸…æ™°ã€å¯æ‰©å±•çš„å®Œæ•´ç³»ç»Ÿæ¶æ„ã€‚æœ¬æ–‡æ¡£æ¶µç›–äº†æ•´ä¸ªé¡¹ç›®çš„æ¶æ„è®¾è®¡ï¼Œç¡®ä¿åç»­å¼€å‘å·¥ä½œèƒ½å¤ŸåŸºäºç»Ÿä¸€çš„æ¶æ„è§„èŒƒè¿›è¡Œã€‚

## ğŸ“‹ ç›®å½•

1. [ç³»ç»Ÿæ¦‚è§ˆ](#ç³»ç»Ÿæ¦‚è§ˆ)
2. [æ ¸å¿ƒæ¶æ„åŸåˆ™](#æ ¸å¿ƒæ¶æ„åŸåˆ™)
3. [æ•´ä½“æ¶æ„è®¾è®¡](#æ•´ä½“æ¶æ„è®¾è®¡)
4. [æ ¸å¿ƒç»„ä»¶æ¶æ„](#æ ¸å¿ƒç»„ä»¶æ¶æ„)
5. [è®¾è®¡æ¨¡å¼åº”ç”¨](#è®¾è®¡æ¨¡å¼åº”ç”¨)
6. [APIå±‚æ¶æ„](#apiå±‚æ¶æ„)
7. [æ•°æ®æµæ¶æ„](#æ•°æ®æµæ¶æ„)
8. [é…ç½®ç®¡ç†æ¶æ„](#é…ç½®ç®¡ç†æ¶æ„)
9. [éƒ¨ç½²æ¶æ„](#éƒ¨ç½²æ¶æ„)
10. [è¯·æ±‚éªŒè¯ç³»ç»Ÿ](#è¯·æ±‚éªŒè¯ç³»ç»Ÿ)

---

## ğŸ¯ ç³»ç»Ÿæ¦‚è§ˆ

GTPlanneræ˜¯ä¸€ä¸ªåŸºäºReActæ¨¡å¼çš„æ™ºèƒ½ä»»åŠ¡è§„åˆ’ç³»ç»Ÿï¼Œé‡‡ç”¨ç°ä»£åŒ–çš„å¾®æœåŠ¡æ¶æ„å’Œæµå¼å“åº”è®¾è®¡ã€‚ç³»ç»Ÿæ”¯æŒå¤šè¯­è¨€ã€å¤šæ¨¡æ€çš„æ™ºèƒ½è§„åˆ’ï¼Œå…·å¤‡å®Œæ•´çš„å·¥å…·ç”Ÿæ€å’Œæ‰©å±•èƒ½åŠ›ã€‚

### æ ¸å¿ƒç‰¹æ€§

- **æ™ºèƒ½è§„åˆ’**ï¼šåŸºäºReActæ¨¡å¼çš„æ™ºèƒ½ä»»åŠ¡åˆ†è§£å’Œæµç¨‹ç”Ÿæˆ
- **æµå¼å“åº”**ï¼šServer-Sent Events (SSE) å®æ—¶å“åº”ç³»ç»Ÿ
- **å¤šè¯­è¨€æ”¯æŒ**ï¼šæ”¯æŒä¸­æ–‡ã€è‹±æ–‡ã€æ—¥æ–‡ã€è¥¿ç­ç‰™æ–‡ã€æ³•æ–‡
- **å·¥å…·ç”Ÿæ€**ï¼šå®Œæ•´çš„å·¥å…·æ¨èå’Œè°ƒç”¨ç³»ç»Ÿ
- **æ— çŠ¶æ€è®¾è®¡**ï¼šæ”¯æŒé«˜å¹¶å‘å’Œæ°´å¹³æ‰©å±•
- **æ¨¡å—åŒ–æ¶æ„**ï¼šåŸºäºè®¾è®¡æ¨¡å¼çš„å¯æ‰©å±•æ¶æ„

### æŠ€æœ¯æ ˆ

- **åç«¯æ¡†æ¶**ï¼šFastAPI + Uvicorn
- **AIæ¡†æ¶**ï¼šOpenAI API + è‡ªå®šä¹‰Agentç³»ç»Ÿ
- **æµå¼å¤„ç†**ï¼šPocketFlow + è‡ªå®šä¹‰æµå¼æ¶æ„
- **æ•°æ®å­˜å‚¨**ï¼šSQLite + å‘é‡æ•°æ®åº“
- **é…ç½®ç®¡ç†**ï¼šDynaconf + TOML
- **å·¥å…·é›†æˆ**ï¼šMCP (Model Context Protocol)

---

## ğŸ›ï¸ æ ¸å¿ƒæ¶æ„åŸåˆ™

### 1. SOLIDåŸåˆ™
- **å•ä¸€èŒè´£åŸåˆ™**ï¼šæ¯ä¸ªç»„ä»¶åªè´Ÿè´£ä¸€ä¸ªæ˜ç¡®çš„åŠŸèƒ½
- **å¼€é—­åŸåˆ™**ï¼šå¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å°é—­
- **é‡Œæ°æ›¿æ¢åŸåˆ™**ï¼šå­ç±»å¯ä»¥å®Œå…¨æ›¿æ¢çˆ¶ç±»
- **æ¥å£éš”ç¦»åŸåˆ™**ï¼šä¾èµ–äºæŠ½è±¡è€Œä¸æ˜¯å…·ä½“å®ç°
- **ä¾èµ–å€’ç½®åŸåˆ™**ï¼šé«˜å±‚æ¨¡å—ä¸ä¾èµ–ä½å±‚æ¨¡å—

### 2. æ¶æ„è®¾è®¡åŸåˆ™
- **æ— çŠ¶æ€è®¾è®¡**ï¼šç»„ä»¶é—´é€šè¿‡æ•°æ®ä¼ é€’ï¼Œä¸ç»´æŠ¤å†…éƒ¨çŠ¶æ€
- **æµå¼ä¼˜å…ˆ**ï¼šæ”¯æŒå®æ—¶å“åº”å’Œæ¸è¿›å¼æ•°æ®ä¼ è¾“
- **æ¨¡å—åŒ–è®¾è®¡**ï¼šé«˜å†…èšã€ä½è€¦åˆçš„ç»„ä»¶è®¾è®¡
- **å¯æ‰©å±•æ€§**ï¼šæ”¯æŒæ°´å¹³æ‰©å±•å’ŒåŠŸèƒ½æ‰©å±•
- **å®¹é”™æ€§**ï¼šä¼˜é›…çš„é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶

---

## ğŸ—ï¸ æ•´ä½“æ¶æ„è®¾è®¡

```mermaid
graph TB
    subgraph "å®¢æˆ·ç«¯å±‚ Client Layer"
        CLI[CLIå®¢æˆ·ç«¯]
        WEB[Webå®¢æˆ·ç«¯]
        MCP[MCPå·¥å…·]
    end
    
    subgraph "APIç½‘å…³å±‚ API Gateway"
        FAST[FastAPIæœåŠ¡å™¨]
        CORS[CORSä¸­é—´ä»¶]
        VALID[è¯·æ±‚éªŒè¯ä¸­é—´ä»¶]
    end
    
    subgraph "ä¸šåŠ¡é€»è¾‘å±‚ Business Logic"
        PLAN[StatelessGTPlanner]
        ORCH[ReActç¼–æ’å™¨]
        STREAM[æµå¼å“åº”ç³»ç»Ÿ]
    end
    
    subgraph "æ ¸å¿ƒæœåŠ¡å±‚ Core Services"
        AGENT[Agentç³»ç»Ÿ]
        TOOLS[å·¥å…·ç³»ç»Ÿ]
        PROMPT[æç¤ºè¯ç³»ç»Ÿ]
        MULTI[å¤šè¯­è¨€ç³»ç»Ÿ]
    end
    
    subgraph "æ•°æ®å±‚ Data Layer"
        SQLITE[SQLiteæ•°æ®åº“]
        VECTOR[å‘é‡æ•°æ®åº“]
        CONFIG[é…ç½®ç³»ç»Ÿ]
    end
    
    subgraph "å¤–éƒ¨æœåŠ¡ External Services"
        LLM[LLM API]
        SEARCH[æœç´¢æœåŠ¡]
        VECTOR_SVC[å‘é‡æœåŠ¡]
    end
    
    CLI --> FAST
    WEB --> FAST
    MCP --> FAST
    
    FAST --> CORS
    CORS --> VALID
    VALID --> PLAN
    
    PLAN --> ORCH
    PLAN --> STREAM
    
    ORCH --> AGENT
    ORCH --> TOOLS
    ORCH --> PROMPT
    ORCH --> MULTI
    
    AGENT --> SQLITE
    TOOLS --> VECTOR
    PROMPT --> CONFIG
    MULTI --> CONFIG
    
    AGENT --> LLM
    TOOLS --> SEARCH
    TOOLS --> VECTOR_SVC
```

---

## ğŸ§© æ ¸å¿ƒç»„ä»¶æ¶æ„

### 1. Agentç³»ç»Ÿæ¶æ„

```mermaid
graph LR
    subgraph "Agentæ ¸å¿ƒ"
        CTX[AgentContext]
        PLAN[StatelessGTPlanner]
        FACT[PocketFlowFactory]
    end
    
    subgraph "æ‰§è¡Œå¼•æ“"
        FLOW[ReActFlow]
        NODE[æ‰§è¡ŒèŠ‚ç‚¹]
        TOOL[å·¥å…·æ‰§è¡Œå™¨]
    end
    
    subgraph "å­æµç¨‹ç³»ç»Ÿ"
        SHORT[çŸ­æœŸè§„åˆ’]
        RESEARCH[æŠ€æœ¯è°ƒç ”]
        DESIGN[æ¶æ„è®¾è®¡]
    end
    
    CTX --> PLAN
    PLAN --> FACT
    FACT --> FLOW
    
    FLOW --> NODE
    NODE --> TOOL
    
    FLOW --> SHORT
    FLOW --> RESEARCH
    FLOW --> DESIGN
```

#### Agentç³»ç»Ÿç»„ä»¶èŒè´£

- **AgentContext**ï¼šæ— çŠ¶æ€ä¸Šä¸‹æ–‡æ•°æ®ç»“æ„
- **StatelessGTPlanner**ï¼šæ— çŠ¶æ€è§„åˆ’å™¨ä¸»æ§åˆ¶å™¨
- **PocketFlowFactory**ï¼šæ•°æ®è½¬æ¢å·¥å‚
- **ReActFlow**ï¼šReActæ¨¡å¼ç¼–æ’å™¨
- **ExecutionNode**ï¼šåŸå­æ“ä½œæ‰§è¡ŒèŠ‚ç‚¹
- **ToolExecutor**ï¼šå·¥å…·è°ƒç”¨æ‰§è¡Œå™¨

### 2. æµå¼å“åº”ç³»ç»Ÿæ¶æ„

```mermaid
graph TB
    subgraph "æµå¼æ¥å£å±‚"
        INTERFACE[StreamingSession]
        MANAGER[StreamingManager]
        HANDLER[StreamHandler]
    end
    
    subgraph "äº‹ä»¶ç³»ç»Ÿ"
        EVENT[StreamEvent]
        BUILDER[StreamEventBuilder]
        TYPE[StreamEventType]
    end
    
    subgraph "å¤„ç†å™¨å±‚"
        CLI_H[CLIStreamHandler]
        SSE_H[SSEStreamHandler]
        CUSTOM[è‡ªå®šä¹‰å¤„ç†å™¨]
    end
    
    INTERFACE --> MANAGER
    MANAGER --> HANDLER
    
    HANDLER --> EVENT
    EVENT --> BUILDER
    BUILDER --> TYPE
    
    HANDLER --> CLI_H
    HANDLER --> SSE_H
    HANDLER --> CUSTOM
```

### 3. å·¥å…·ç³»ç»Ÿæ¶æ„

```mermaid
graph LR
    subgraph "å·¥å…·ç®¡ç†"
        INDEX[å·¥å…·ç´¢å¼•]
        RECOMMEND[å·¥å…·æ¨è]
        EXECUTOR[å·¥å…·æ‰§è¡Œ]
    end
    
    subgraph "å·¥å…·ç±»å‹"
        API[APIå·¥å…·]
        PYTHON[PythonåŒ…]
        CUSTOM[è‡ªå®šä¹‰å·¥å…·]
    end
    
    subgraph "å‘é‡æœåŠ¡"
        VECTOR[å‘é‡æ•°æ®åº“]
        SEARCH[ç›¸ä¼¼åº¦æœç´¢]
        EMBED[åµŒå…¥ç”Ÿæˆ]
    end
    
    INDEX --> VECTOR
    RECOMMEND --> SEARCH
    EXECUTOR --> API
    EXECUTOR --> PYTHON
    EXECUTOR --> CUSTOM
    
    SEARCH --> EMBED
```

### 4. æŒä¹…åŒ–ç³»ç»Ÿæ¶æ„

```mermaid
graph TB
    subgraph "æ•°æ®è®¿é—®å±‚"
        DAO[DatabaseDAO]
        SESSION[SessionManager]
        COMPRESS[SmartCompressor]
    end
    
    subgraph "æ•°æ®å­˜å‚¨å±‚"
        SQLITE[SQLiteæ•°æ®åº“]
        SCHEMA[æ•°æ®åº“æ¶æ„]
        MIGRATE[è¿ç§»ç®¡ç†]
    end
    
    subgraph "æ•°æ®æ¨¡å‹"
        SESSIONS[ä¼šè¯è¡¨]
        MESSAGES[æ¶ˆæ¯è¡¨]
        CONTEXT[å‹ç¼©ä¸Šä¸‹æ–‡è¡¨]
    end
    
    DAO --> SQLITE
    SESSION --> DAO
    COMPRESS --> SESSION
    
    SQLITE --> SCHEMA
    SCHEMA --> MIGRATE
    
    SCHEMA --> SESSIONS
    SCHEMA --> MESSAGES
    SCHEMA --> CONTEXT
```

---

## ğŸ¨ è®¾è®¡æ¨¡å¼åº”ç”¨

### 1. åˆ›å»ºå‹æ¨¡å¼

#### å·¥å‚æ¨¡å¼ (Factory Pattern)
- **PocketFlowFactory**ï¼šè´Ÿè´£AgentContextå’Œsharedå­—å…¸çš„è½¬æ¢
- **ValidatorFactory**ï¼šåˆ›å»ºä¸åŒç±»å‹çš„éªŒè¯å™¨
- **PromptFactory**ï¼šåˆ›å»ºå¤šè¯­è¨€æç¤ºè¯æ¨¡æ¿

#### å•ä¾‹æ¨¡å¼ (Singleton Pattern)
- **PromptManager**ï¼šå…¨å±€æç¤ºè¯ç®¡ç†å™¨
- **StreamingManager**ï¼šå…¨å±€æµå¼å“åº”ç®¡ç†å™¨
- **ConfigManager**ï¼šå…¨å±€é…ç½®ç®¡ç†å™¨

### 2. ç»“æ„å‹æ¨¡å¼

#### è£…é¥°å™¨æ¨¡å¼ (Decorator Pattern)
- **ValidationMiddleware**ï¼šè¯·æ±‚éªŒè¯è£…é¥°å™¨
- **StreamingDecorator**ï¼šæµå¼å“åº”è£…é¥°å™¨
- **TracingDecorator**ï¼šæ‰§è¡Œè¿½è¸ªè£…é¥°å™¨

#### é€‚é…å™¨æ¨¡å¼ (Adapter Pattern)
- **LLMAdapter**ï¼šä¸åŒLLMæœåŠ¡çš„é€‚é…å™¨
- **DatabaseAdapter**ï¼šä¸åŒæ•°æ®åº“çš„é€‚é…å™¨
- **ToolAdapter**ï¼šä¸åŒå·¥å…·ç±»å‹çš„é€‚é…å™¨

### 3. è¡Œä¸ºå‹æ¨¡å¼

#### ç­–ç•¥æ¨¡å¼ (Strategy Pattern)
- **ValidationStrategy**ï¼šä¸åŒçš„éªŒè¯ç­–ç•¥
- **CompressionStrategy**ï¼šä¸åŒçš„å‹ç¼©ç­–ç•¥
- **LanguageStrategy**ï¼šä¸åŒçš„è¯­è¨€å¤„ç†ç­–ç•¥

#### è´£ä»»é“¾æ¨¡å¼ (Chain of Responsibility)
- **ValidationChain**ï¼šéªŒè¯è´£ä»»é“¾
- **MiddlewareChain**ï¼šä¸­é—´ä»¶è´£ä»»é“¾
- **ProcessingChain**ï¼šå¤„ç†æµç¨‹è´£ä»»é“¾

#### è§‚å¯Ÿè€…æ¨¡å¼ (Observer Pattern)
- **StreamEventObserver**ï¼šæµå¼äº‹ä»¶è§‚å¯Ÿè€…
- **ValidationObserver**ï¼šéªŒè¯äº‹ä»¶è§‚å¯Ÿè€…
- **MetricsObserver**ï¼šæŒ‡æ ‡æ”¶é›†è§‚å¯Ÿè€…

#### æ¨¡æ¿æ–¹æ³•æ¨¡å¼ (Template Method Pattern)
- **BaseValidator**ï¼šéªŒè¯å™¨åŸºç±»æ¨¡æ¿
- **BaseNode**ï¼šèŠ‚ç‚¹æ‰§è¡Œæ¨¡æ¿
- **BaseHandler**ï¼šå¤„ç†å™¨åŸºç±»æ¨¡æ¿

---

## ğŸŒ APIå±‚æ¶æ„

### 1. RESTful APIè®¾è®¡

```python
# ä¸»è¦APIç«¯ç‚¹è®¾è®¡
@app.post("/api/chat/agent")
async def chat_agent_stream(request: AgentContextRequest):
    """SSEæµå¼èŠå¤©ç«¯ç‚¹ - GTPlanner Agent"""
    pass

@app.get("/health")
async def health_check():
    """å¥åº·æ£€æŸ¥ç«¯ç‚¹"""
    pass

@app.get("/api/status")
async def api_status():
    """è·å–è¯¦ç»†çš„APIçŠ¶æ€ä¿¡æ¯"""
    pass
```

#### APIå±‚ç»„ä»¶è®¾è®¡

```mermaid
graph TB
    subgraph "APIç½‘å…³å±‚"
        FAST[FastAPIåº”ç”¨]
        MIDDLEWARE[ä¸­é—´ä»¶æ ˆ]
        ROUTER[è·¯ç”±ç®¡ç†]
    end
    
    subgraph "è¯·æ±‚å¤„ç†å±‚"
        VALIDATION[è¯·æ±‚éªŒè¯]
        TRANSFORM[æ•°æ®è½¬æ¢]
        RESPONSE[å“åº”å¤„ç†]
    end
    
    subgraph "ä¸šåŠ¡æ¥å£å±‚"
        SSE_API[SSE GTPlanner API]
        MCP_API[MCPæœåŠ¡API]
        HEALTH[å¥åº·æ£€æŸ¥API]
    end
    
    FAST --> MIDDLEWARE
    MIDDLEWARE --> ROUTER
    ROUTER --> VALIDATION
    
    VALIDATION --> TRANSFORM
    TRANSFORM --> RESPONSE
    
    RESPONSE --> SSE_API
    RESPONSE --> MCP_API
    RESPONSE --> HEALTH
```

### 2. SSEæµå¼å“åº”æ¶æ„

```python
class SSEGTPlanner:
    """åŸºäºæ–°æµå¼å“åº”æ¶æ„çš„GTPlanner SSE API"""
    
    async def process_request_stream(
        self,
        agent_context: Dict[str, Any],
        response_writer: Callable[[str], Awaitable[None]],
        language: Optional[str] = None,
        **config_options
    ) -> Dict[str, Any]:
        """å¤„ç†ç”¨æˆ·è¯·æ±‚å¹¶é€šè¿‡SSEæµå¼è¿”å›ç»“æœ"""
        pass
```

#### SSEäº‹ä»¶æµè®¾è®¡

```mermaid
sequenceDiagram
    participant Client
    participant SSE_API
    participant StreamingSession
    participant StatelessGTPlanner
    participant LLM
    
    Client->>SSE_API: POST /api/chat/agent
    SSE_API->>StreamingSession: åˆ›å»ºæµå¼ä¼šè¯
    SSE_API->>Client: connectionäº‹ä»¶
    
    SSE_API->>StatelessGTPlanner: å¤„ç†è¯·æ±‚
    StatelessGTPlanner->>LLM: LLMè°ƒç”¨
    LLM-->>StreamingSession: assistant_message_chunk
    StreamingSession-->>Client: SSEæ•°æ®æµ
    
    StatelessGTPlanner->>StatelessGTPlanner: å·¥å…·è°ƒç”¨
    StatelessGTPlanner-->>StreamingSession: tool_call_progress
    StreamingSession-->>Client: SSEæ•°æ®æµ
    
    StatelessGTPlanner->>SSE_API: å¤„ç†å®Œæˆ
    SSE_API->>Client: completeäº‹ä»¶
    SSE_API->>Client: closeäº‹ä»¶
```

### 3. MCPæœåŠ¡é›†æˆ

```python
# MCPæœåŠ¡æ¶æ„
@app.tool(description="Generate workflow based on user requirements")
async def generate_flow(
    requirement: str,
    previous_flow: Optional[str] = None,
    language: Optional[str] = None,
    user_id: Optional[str] = None,
) -> dict:
    """Generate workflow with multilingual support"""
    pass

@app.tool(description="Generate detailed design document")
async def generate_design_doc(
    requirement: str,
    previous_flow: str,
    design_doc: Optional[Any] = None,
    language: Optional[str] = None,
    user_id: Optional[str] = None,
) -> dict:
    """Generate detailed design document with multilingual support"""
    pass
```

---

## ğŸŒŠ æ•°æ®æµæ¶æ„

### 1. æ— çŠ¶æ€æ•°æ®æµè®¾è®¡

```mermaid
graph LR
    subgraph "è¾“å…¥å±‚"
        USER[ç”¨æˆ·è¾“å…¥]
        CONTEXT[AgentContext]
        CONFIG[é…ç½®å‚æ•°]
    end
    
    subgraph "å¤„ç†å±‚"
        FACTORY[PocketFlowFactory]
        SHARED[Sharedå­—å…¸]
        PLANNER[StatelessGTPlanner]
    end
    
    subgraph "æ‰§è¡Œå±‚"
        ORCHESTRATOR[ReActç¼–æ’å™¨]
        NODES[æ‰§è¡ŒèŠ‚ç‚¹]
        TOOLS[å·¥å…·è°ƒç”¨]
    end
    
    subgraph "è¾“å‡ºå±‚"
        RESULT[AgentResult]
        STREAM[æµå¼äº‹ä»¶]
        PERSIST[æŒä¹…åŒ–]
    end
    
    USER --> CONTEXT
    CONTEXT --> FACTORY
    CONFIG --> FACTORY
    
    FACTORY --> SHARED
    SHARED --> PLANNER
    
    PLANNER --> ORCHESTRATOR
    ORCHESTRATOR --> NODES
    NODES --> TOOLS
    
    TOOLS --> RESULT
    ORCHESTRATOR --> STREAM
    RESULT --> PERSIST
```

### 2. ä¸Šä¸‹æ–‡æ•°æ®ç»“æ„

```python
@dataclass
class AgentContext:
    """æ— çŠ¶æ€Agentä¸Šä¸‹æ–‡"""
    session_id: str
    dialogue_history: List[Message]
    tool_execution_results: Dict[str, Any]
    session_metadata: Dict[str, Any]
    last_updated: Optional[str] = None
    is_compressed: bool = False
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'AgentContext':
        """ä»å­—å…¸åˆ›å»ºAgentContextå®ä¾‹"""
        pass
    
    def to_dict(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºå­—å…¸æ ¼å¼"""
        pass
```

### 3. æ¶ˆæ¯æµè½¬æ¶æ„

```mermaid
graph TB
    subgraph "æ¶ˆæ¯ç±»å‹"
        USER_MSG[ç”¨æˆ·æ¶ˆæ¯]
        ASSISTANT_MSG[åŠ©æ‰‹æ¶ˆæ¯]
        TOOL_MSG[å·¥å…·æ¶ˆæ¯]
        SYSTEM_MSG[ç³»ç»Ÿæ¶ˆæ¯]
    end
    
    subgraph "æ¶ˆæ¯å¤„ç†"
        PARSER[æ¶ˆæ¯è§£æå™¨]
        VALIDATOR[æ¶ˆæ¯éªŒè¯å™¨]
        TRANSFORMER[æ¶ˆæ¯è½¬æ¢å™¨]
    end
    
    subgraph "æ¶ˆæ¯å­˜å‚¨"
        MEMORY[å†…å­˜ç¼“å­˜]
        DATABASE[æ•°æ®åº“å­˜å‚¨]
        COMPRESS[æ™ºèƒ½å‹ç¼©]
    end
    
    USER_MSG --> PARSER
    ASSISTANT_MSG --> PARSER
    TOOL_MSG --> PARSER
    SYSTEM_MSG --> PARSER
    
    PARSER --> VALIDATOR
    VALIDATOR --> TRANSFORMER
    
    TRANSFORMER --> MEMORY
    MEMORY --> DATABASE
    DATABASE --> COMPRESS
```

---

## âš™ï¸ é…ç½®ç®¡ç†æ¶æ„

### 1. åˆ†å±‚é…ç½®è®¾è®¡

```toml
# settings.toml - ä¸»é…ç½®æ–‡ä»¶
[default]
debug = true

[default.logging]
level = "INFO"
file_enabled = true
console_enabled = false

[default.llm]
base_url = "@format {env[LLM_BASE_URL]}"
api_key = "@format {env[LLM_API_KEY]}"
model = "@format {env[LLM_MODEL]}"

[default.multilingual]
default_language = "en"
auto_detect = true
fallback_enabled = true
supported_languages = ["en", "zh", "es", "fr", "ja"]

[default.vector_service]
base_url = "http://localhost:8080"
timeout = 30
tools_index_name = "document_gtplanner_tools"
vector_field = "combined_text"
```

### 2. é…ç½®ç®¡ç†æ¶æ„

```python
class MultilingualConfig:
    """å¤šè¯­è¨€é…ç½®ç®¡ç†å™¨"""
    
    def __init__(self, settings_file: str = "settings.toml"):
        self._settings = Dynaconf(
            settings_files=[settings_file],
            environments=True,
            load_dotenv=True,
            envvar_prefix="GTPLANNER"
        )
    
    def get_llm_config(self) -> Dict[str, Any]:
        """è·å–LLMé…ç½®"""
        pass
    
    def get_vector_service_config(self) -> Dict[str, Any]:
        """è·å–å‘é‡æœåŠ¡é…ç½®"""
        pass
```

### 3. ç¯å¢ƒå˜é‡ç®¡ç†

```mermaid
graph TB
    subgraph "é…ç½®æ¥æº"
        ENV[ç¯å¢ƒå˜é‡]
        TOML[TOMLæ–‡ä»¶]
        SECRETS[å¯†é’¥æ–‡ä»¶]
        DEFAULT[é»˜è®¤å€¼]
    end
    
    subgraph "é…ç½®ç®¡ç†"
        DYNACONF[Dynaconf]
        LOADER[é…ç½®åŠ è½½å™¨]
        VALIDATOR[é…ç½®éªŒè¯å™¨]
    end
    
    subgraph "é…ç½®ä½¿ç”¨"
        LLM_CONFIG[LLMé…ç½®]
        DB_CONFIG[æ•°æ®åº“é…ç½®]
        VECTOR_CONFIG[å‘é‡æœåŠ¡é…ç½®]
        MULTI_CONFIG[å¤šè¯­è¨€é…ç½®]
    end
    
    ENV --> DYNACONF
    TOML --> DYNACONF
    SECRETS --> DYNACONF
    DEFAULT --> DYNACONF
    
    DYNACONF --> LOADER
    LOADER --> VALIDATOR
    
    VALIDATOR --> LLM_CONFIG
    VALIDATOR --> DB_CONFIG
    VALIDATOR --> VECTOR_CONFIG
    VALIDATOR --> MULTI_CONFIG
```

---

## ğŸš€ éƒ¨ç½²æ¶æ„

### 1. å®¹å™¨åŒ–éƒ¨ç½²

```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .
EXPOSE 11211 8001

CMD ["python", "fastapi_main.py"]
```

### 2. æœåŠ¡æ‹“æ‰‘

```mermaid
graph TB
    subgraph "è´Ÿè½½å‡è¡¡å±‚"
        LB[è´Ÿè½½å‡è¡¡å™¨]
        CDN[CDN]
    end
    
    subgraph "åº”ç”¨æœåŠ¡å±‚"
        APP1[GTPlannerå®ä¾‹1]
        APP2[GTPlannerå®ä¾‹2]
        APP3[GTPlannerå®ä¾‹3]
    end
    
    subgraph "æ•°æ®æœåŠ¡å±‚"
        SQLITE[SQLiteæ•°æ®åº“]
        VECTOR[å‘é‡æ•°æ®åº“]
        REDIS[Redisç¼“å­˜]
    end
    
    subgraph "å¤–éƒ¨æœåŠ¡å±‚"
        LLM_SVC[LLMæœåŠ¡]
        SEARCH_SVC[æœç´¢æœåŠ¡]
        VECTOR_SVC[å‘é‡æœåŠ¡]
    end
    
    LB --> APP1
    LB --> APP2
    LB --> APP3
    
    APP1 --> SQLITE
    APP2 --> SQLITE
    APP3 --> SQLITE
    
    APP1 --> VECTOR
    APP2 --> VECTOR
    APP3 --> VECTOR
    
    APP1 --> LLM_SVC
    APP2 --> SEARCH_SVC
    APP3 --> VECTOR_SVC
```

---

## ğŸ”’ è¯·æ±‚éªŒè¯ç³»ç»Ÿæ¶æ„è®¾è®¡

### ğŸ“ è®¾è®¡æ¨¡å¼åº”ç”¨

**1. ç­–ç•¥æ¨¡å¼ï¼ˆStrategy Patternï¼‰** - éªŒè¯ç­–ç•¥
**2. è´£ä»»é“¾æ¨¡å¼ï¼ˆChain of Responsibilityï¼‰** - éªŒè¯é“¾  
**3. å·¥å‚æ¨¡å¼ï¼ˆFactory Patternï¼‰** - éªŒè¯å™¨åˆ›å»º
**4. è£…é¥°å™¨æ¨¡å¼ï¼ˆDecorator Patternï¼‰** - ä¸­é—´ä»¶è£…é¥°
**5. è§‚å¯Ÿè€…æ¨¡å¼ï¼ˆObserver Patternï¼‰** - éªŒè¯äº‹ä»¶é€šçŸ¥
**6. æ¨¡æ¿æ–¹æ³•æ¨¡å¼ï¼ˆTemplate Method Patternï¼‰** - éªŒè¯å™¨åŸºç±»æ¨¡æ¿
**7. å»ºé€ è€…æ¨¡å¼ï¼ˆBuilder Patternï¼‰** - å¤æ‚éªŒè¯è§„åˆ™æ„å»º
**8. é€‚é…å™¨æ¨¡å¼ï¼ˆAdapter Patternï¼‰** - ä¸åŒéªŒè¯æ¡†æ¶é€‚é…

### ğŸ“ ç›®å½•ç»“æ„

```
GTPlanner/
â”œâ”€â”€ agent/
â”‚   â””â”€â”€ validation/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ core/
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ interfaces.py          # æŠ½è±¡æ¥å£å®šä¹‰
â”‚       â”‚   â”œâ”€â”€ base_validator.py      # åŸºç¡€éªŒè¯å™¨æ¨¡æ¿
â”‚       â”‚   â”œâ”€â”€ validation_context.py  # éªŒè¯ä¸Šä¸‹æ–‡
â”‚       â”‚   â”œâ”€â”€ validation_result.py   # éªŒè¯ç»“æœ
â”‚       â”‚   â”œâ”€â”€ validation_error.py    # éªŒè¯é”™è¯¯å®šä¹‰
â”‚       â”‚   â””â”€â”€ validation_registry.py # éªŒè¯å™¨æ³¨å†Œè¡¨
â”‚       â”œâ”€â”€ strategies/
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ size_validator.py      # å¤§å°éªŒè¯ç­–ç•¥
â”‚       â”‚   â”œâ”€â”€ format_validator.py    # æ ¼å¼éªŒè¯ç­–ç•¥
â”‚       â”‚   â”œâ”€â”€ content_validator.py   # å†…å®¹éªŒè¯ç­–ç•¥
â”‚       â”‚   â”œâ”€â”€ security_validator.py  # å®‰å…¨éªŒè¯ç­–ç•¥
â”‚       â”‚   â”œâ”€â”€ rate_limit_validator.py # é¢‘ç‡é™åˆ¶ç­–ç•¥
â”‚       â”‚   â”œâ”€â”€ language_validator.py  # å¤šè¯­è¨€éªŒè¯ç­–ç•¥
â”‚       â”‚   â””â”€â”€ session_validator.py   # ä¼šè¯éªŒè¯ç­–ç•¥
â”‚       â”œâ”€â”€ chains/
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ validation_chain.py    # éªŒè¯è´£ä»»é“¾
â”‚       â”‚   â”œâ”€â”€ chain_builder.py       # é“¾æ„å»ºå™¨
â”‚       â”‚   â””â”€â”€ async_validation_chain.py # å¼‚æ­¥éªŒè¯é“¾
â”‚       â”œâ”€â”€ factories/
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ validator_factory.py   # éªŒè¯å™¨å·¥å‚
â”‚       â”‚   â”œâ”€â”€ chain_factory.py       # é“¾å·¥å‚
â”‚       â”‚   â””â”€â”€ config_factory.py      # é…ç½®å·¥å‚
â”‚       â”œâ”€â”€ middleware/
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ validation_middleware.py # éªŒè¯ä¸­é—´ä»¶
â”‚       â”‚   â”œâ”€â”€ error_middleware.py     # é”™è¯¯å¤„ç†ä¸­é—´ä»¶
â”‚       â”‚   â””â”€â”€ cors_validation_middleware.py # CORSéªŒè¯ä¸­é—´ä»¶
â”‚       â”œâ”€â”€ observers/
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ validation_observer.py  # éªŒè¯è§‚å¯Ÿè€…
â”‚       â”‚   â”œâ”€â”€ metrics_observer.py     # æŒ‡æ ‡æ”¶é›†è§‚å¯Ÿè€…
â”‚       â”‚   â”œâ”€â”€ logging_observer.py     # æ—¥å¿—è§‚å¯Ÿè€…
â”‚       â”‚   â””â”€â”€ streaming_observer.py   # æµå¼å“åº”è§‚å¯Ÿè€…
â”‚       â”œâ”€â”€ adapters/
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ pydantic_adapter.py     # PydanticéªŒè¯é€‚é…å™¨
â”‚       â”‚   â”œâ”€â”€ fastapi_adapter.py      # FastAPIéªŒè¯é€‚é…å™¨
â”‚       â”‚   â””â”€â”€ sse_adapter.py          # SSEæµå¼éªŒè¯é€‚é…å™¨
â”‚       â”œâ”€â”€ config/
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ validation_config.py    # éªŒè¯é…ç½®ç®¡ç†å™¨
â”‚       â”‚   â”œâ”€â”€ rules.py               # éªŒè¯è§„åˆ™å®šä¹‰
â”‚       â”‚   â””â”€â”€ endpoint_config.py      # ç«¯ç‚¹éªŒè¯é…ç½®
â”‚       â””â”€â”€ utils/
â”‚           â”œâ”€â”€ __init__.py
â”‚           â”œâ”€â”€ validation_utils.py     # éªŒè¯å·¥å…·å‡½æ•°
â”‚           â”œâ”€â”€ error_formatters.py     # é”™è¯¯æ ¼å¼åŒ–å·¥å…·
â”‚           â””â”€â”€ cache_manager.py        # éªŒè¯ç¼“å­˜ç®¡ç†
```

## ğŸ¯ æ ¸å¿ƒæ¶æ„è®¾è®¡

### 1. æ¥å£å®šä¹‰ï¼ˆInterface Segregation Principleï¼‰

```python
# agent/validation/core/interfaces.py
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional, AsyncIterator
from enum import Enum
from .validation_context import ValidationContext
from .validation_result import ValidationResult
from .validation_error import ValidationError

class ValidatorPriority(Enum):
    """éªŒè¯å™¨ä¼˜å…ˆçº§"""
    CRITICAL = 1    # å…³é”®éªŒè¯ï¼ˆå®‰å…¨ã€è®¤è¯ï¼‰
    HIGH = 2        # é«˜ä¼˜å…ˆçº§ï¼ˆæ ¼å¼ã€å¤§å°ï¼‰
    MEDIUM = 3      # ä¸­ä¼˜å…ˆçº§ï¼ˆå†…å®¹ã€è¯­è¨€ï¼‰
    LOW = 4         # ä½ä¼˜å…ˆçº§ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰

class IValidator(ABC):
    """éªŒè¯å™¨æ¥å£"""
    
    @abstractmethod
    async def validate(self, context: ValidationContext) -> ValidationResult:
        """æ‰§è¡ŒéªŒè¯"""
        pass
    
    @abstractmethod
    def get_validator_name(self) -> str:
        """è·å–éªŒè¯å™¨åç§°"""
        pass
    
    @abstractmethod
    def get_priority(self) -> ValidatorPriority:
        """è·å–éªŒè¯å™¨ä¼˜å…ˆçº§"""
        pass
    
    @abstractmethod
    def supports_async(self) -> bool:
        """æ˜¯å¦æ”¯æŒå¼‚æ­¥éªŒè¯"""
        pass

class IValidationStrategy(ABC):
    """éªŒè¯ç­–ç•¥æ¥å£"""
    
    @abstractmethod
    async def execute(self, data: Any, rules: Dict[str, Any]) -> ValidationResult:
        """æ‰§è¡ŒéªŒè¯ç­–ç•¥"""
        pass
    
    @abstractmethod
    def get_strategy_name(self) -> str:
        """è·å–ç­–ç•¥åç§°"""
        pass

class IValidationChain(ABC):
    """éªŒè¯é“¾æ¥å£"""
    
    @abstractmethod
    def add_validator(self, validator: IValidator) -> 'IValidationChain':
        """æ·»åŠ éªŒè¯å™¨"""
        pass
    
    @abstractmethod
    def remove_validator(self, validator_name: str) -> 'IValidationChain':
        """ç§»é™¤éªŒè¯å™¨"""
        pass
    
    @abstractmethod
    async def validate(self, context: ValidationContext) -> ValidationResult:
        """æ‰§è¡ŒéªŒè¯é“¾"""
        pass
    
    @abstractmethod
    async def validate_parallel(self, context: ValidationContext) -> ValidationResult:
        """å¹¶è¡Œæ‰§è¡ŒéªŒè¯é“¾"""
        pass

class IValidationObserver(ABC):
    """éªŒè¯è§‚å¯Ÿè€…æ¥å£"""
    
    @abstractmethod
    async def on_validation_start(self, context: ValidationContext) -> None:
        """éªŒè¯å¼€å§‹äº‹ä»¶"""
        pass
    
    @abstractmethod
    async def on_validation_step(self, validator_name: str, result: ValidationResult) -> None:
        """éªŒè¯æ­¥éª¤å®Œæˆäº‹ä»¶"""
        pass
    
    @abstractmethod
    async def on_validation_complete(self, result: ValidationResult) -> None:
        """éªŒè¯å®Œæˆäº‹ä»¶"""
        pass
    
    @abstractmethod
    async def on_validation_error(self, error: Exception, context: Optional[ValidationContext] = None) -> None:
        """éªŒè¯é”™è¯¯äº‹ä»¶"""
        pass

class IValidationMiddleware(ABC):
    """éªŒè¯ä¸­é—´ä»¶æ¥å£"""
    
    @abstractmethod
    async def process_request(self, request: Any, call_next: Any) -> Any:
        """å¤„ç†è¯·æ±‚"""
        pass
    
    @abstractmethod
    def get_middleware_name(self) -> str:
        """è·å–ä¸­é—´ä»¶åç§°"""
        pass

class IValidationCache(ABC):
    """éªŒè¯ç¼“å­˜æ¥å£"""
    
    @abstractmethod
    async def get(self, key: str) -> Optional[ValidationResult]:
        """è·å–ç¼“å­˜ç»“æœ"""
        pass
    
    @abstractmethod
    async def set(self, key: str, result: ValidationResult, ttl: int = 300) -> None:
        """è®¾ç½®ç¼“å­˜ç»“æœ"""
        pass
    
    @abstractmethod
    async def invalidate(self, pattern: str) -> None:
        """å¤±æ•ˆç¼“å­˜"""
        pass

class IValidationMetrics(ABC):
    """éªŒè¯æŒ‡æ ‡æ¥å£"""
    
    @abstractmethod
    def record_validation_time(self, validator_name: str, duration: float) -> None:
        """è®°å½•éªŒè¯æ—¶é—´"""
        pass
    
    @abstractmethod
    def record_validation_result(self, validator_name: str, success: bool) -> None:
        """è®°å½•éªŒè¯ç»“æœ"""
        pass
    
    @abstractmethod
    def get_metrics(self) -> Dict[str, Any]:
        """è·å–æŒ‡æ ‡æ•°æ®"""
        pass
```

### 2. éªŒè¯ä¸Šä¸‹æ–‡ï¼ˆContext Patternï¼‰

```python
# agent/validation/core/validation_context.py
from dataclasses import dataclass, field
from typing import Any, Dict, Optional, List, Union
from datetime import datetime
from fastapi import Request
from enum import Enum

class ValidationMode(Enum):
    """éªŒè¯æ¨¡å¼"""
    STRICT = "strict"        # ä¸¥æ ¼æ¨¡å¼ï¼šæ‰€æœ‰éªŒè¯å™¨å¿…é¡»é€šè¿‡
    LENIENT = "lenient"      # å®½æ¾æ¨¡å¼ï¼šå…è®¸è­¦å‘Š
    FAIL_FAST = "fail_fast"  # å¿«é€Ÿå¤±è´¥ï¼šé‡åˆ°é”™è¯¯ç«‹å³åœæ­¢
    CONTINUE = "continue"    # ç»§ç»­æ¨¡å¼ï¼šæ”¶é›†æ‰€æœ‰é”™è¯¯åè¿”å›

@dataclass
class ValidationContext:
    """éªŒè¯ä¸Šä¸‹æ–‡ - åŒ…å«å®Œæ•´çš„éªŒè¯ç¯å¢ƒä¿¡æ¯"""
    
    # è¯·æ±‚ç›¸å…³ä¿¡æ¯
    request: Optional[Request] = None
    request_data: Any = None
    request_headers: Dict[str, str] = field(default_factory=dict)
    request_method: str = "POST"
    request_path: str = ""
    request_size: int = 0
    
    # éªŒè¯é…ç½®
    validation_rules: Dict[str, Any] = field(default_factory=dict)
    validation_mode: ValidationMode = ValidationMode.STRICT
    skip_validators: List[str] = field(default_factory=list)
    enabled_validators: List[str] = field(default_factory=list)
    
    # ä¼šè¯å’Œç”¨æˆ·ä¿¡æ¯
    request_id: str = field(default_factory=lambda: f"req_{datetime.now().timestamp()}")
    user_id: Optional[str] = None
    session_id: Optional[str] = None
    client_ip: Optional[str] = None
    user_agent: Optional[str] = None
    
    # å¤šè¯­è¨€æ”¯æŒ
    language: Optional[str] = None
    detected_language: Optional[str] = None
    supported_languages: List[str] = field(default_factory=lambda: ["en", "zh", "es", "fr", "ja"])
    
    # éªŒè¯çŠ¶æ€è¿½è¸ª
    current_validator: Optional[str] = None
    validation_path: List[str] = field(default_factory=list)
    validation_start_time: Optional[datetime] = None
    validation_metadata: Dict[str, Any] = field(default_factory=dict)
    
    # ç¼“å­˜å’Œæ€§èƒ½
    cache_key: Optional[str] = None
    enable_cache: bool = True
    cache_ttl: int = 300  # 5åˆ†é’Ÿ
    
    # æµå¼å“åº”æ”¯æŒ
    streaming_session: Optional[Any] = None  # StreamingSession
    enable_streaming_validation: bool = False
    
    def __post_init__(self):
        """åˆå§‹åŒ–åå¤„ç†"""
        if self.validation_start_time is None:
            self.validation_start_time = datetime.now()
        
        # ä»requestä¸­æå–ä¿¡æ¯
        if self.request:
            self._extract_request_info()
        
        # ç”Ÿæˆç¼“å­˜é”®
        if self.enable_cache and not self.cache_key:
            self._generate_cache_key()
    
    def _extract_request_info(self) -> None:
        """ä»FastAPI Requestå¯¹è±¡ä¸­æå–ä¿¡æ¯"""
        if not self.request:
            return
            
        self.request_headers = dict(self.request.headers)
        self.request_method = self.request.method
        self.request_path = str(self.request.url.path)
        self.client_ip = self.request.client.host if self.request.client else None
        self.user_agent = self.request_headers.get("user-agent")
        
        # æå–Content-Length
        content_length = self.request_headers.get("content-length")
        if content_length:
            try:
                self.request_size = int(content_length)
            except ValueError:
                self.request_size = 0
    
    def _generate_cache_key(self) -> None:
        """ç”ŸæˆéªŒè¯ç¼“å­˜é”®"""
        key_parts = [
            self.request_method,
            self.request_path,
            str(self.request_size),
            self.user_id or "anonymous",
            str(hash(str(self.validation_rules)))
        ]
        self.cache_key = "|".join(key_parts)
    
    def should_skip_validator(self, validator_name: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦åº”è·³è¿‡æŒ‡å®šéªŒè¯å™¨"""
        if validator_name in self.skip_validators:
            return True
        
        # å¦‚æœæŒ‡å®šäº†enabled_validatorsï¼Œåªè¿è¡Œåˆ—è¡¨ä¸­çš„éªŒè¯å™¨
        if self.enabled_validators and validator_name not in self.enabled_validators:
            return True
            
        return False
    
    def add_to_path(self, validator_name: str) -> None:
        """æ·»åŠ åˆ°éªŒè¯è·¯å¾„"""
        self.validation_path.append(validator_name)
        self.current_validator = validator_name
    
    def get_execution_time(self) -> float:
        """è·å–éªŒè¯æ‰§è¡Œæ—¶é—´ï¼ˆç§’ï¼‰"""
        if self.validation_start_time:
            return (datetime.now() - self.validation_start_time).total_seconds()
        return 0.0
    
    def is_api_endpoint(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºAPIç«¯ç‚¹"""
        return self.request_path.startswith("/api/")
    
    def is_streaming_request(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºæµå¼è¯·æ±‚"""
        return (
            self.enable_streaming_validation and 
            self.streaming_session is not None
        )
    
    def get_language_preference(self) -> str:
        """è·å–è¯­è¨€åå¥½"""
        # ä¼˜å…ˆçº§ï¼šæ˜¾å¼æŒ‡å®š > æ£€æµ‹åˆ°çš„è¯­è¨€ > é»˜è®¤è¯­è¨€
        return (
            self.language or 
            self.detected_language or 
            (self.supported_languages[0] if self.supported_languages else "en")
        )
    
    def to_dict(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºå­—å…¸æ ¼å¼ï¼ˆç”¨äºæ—¥å¿—å’Œè°ƒè¯•ï¼‰"""
        return {
            "request_id": self.request_id,
            "request_method": self.request_method,
            "request_path": self.request_path,
            "request_size": self.request_size,
            "session_id": self.session_id,
            "user_id": self.user_id,
            "language": self.get_language_preference(),
            "validation_mode": self.validation_mode.value,
            "validation_path": self.validation_path,
            "execution_time": self.get_execution_time(),
            "cache_enabled": self.enable_cache,
            "streaming_enabled": self.enable_streaming_validation
        }
```

### 3. éªŒè¯ç»“æœï¼ˆValue Object Patternï¼‰

```python
# agent/validation/core/validation_result.py
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Union
from datetime import datetime
from enum import Enum

class ValidationStatus(Enum):
    """éªŒè¯çŠ¶æ€"""
    SUCCESS = "success"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"
    SKIPPED = "skipped"

class ValidationSeverity(Enum):
    """éªŒè¯ä¸¥é‡ç¨‹åº¦"""
    LOW = 1
    MEDIUM = 2
    HIGH = 3
    CRITICAL = 4

@dataclass
class ValidationError:
    """éªŒè¯é”™è¯¯è¯¦ç»†ä¿¡æ¯"""
    code: str
    message: str
    field: Optional[str] = None
    value: Optional[Any] = None
    validator: Optional[str] = None
    severity: ValidationSeverity = ValidationSeverity.MEDIUM
    suggestion: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºå­—å…¸æ ¼å¼"""
        return {
            "code": self.code,
            "message": self.message,
            "field": self.field,
            "value": str(self.value) if self.value is not None else None,
            "validator": self.validator,
            "severity": self.severity.name,
            "suggestion": self.suggestion,
            "timestamp": self.timestamp.isoformat()
        }

@dataclass
class ValidationMetrics:
    """éªŒè¯æŒ‡æ ‡"""
    total_validators: int = 0
    executed_validators: int = 0
    skipped_validators: int = 0
    execution_time: float = 0.0
    cache_hits: int = 0
    cache_misses: int = 0
    
    def to_dict(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºå­—å…¸æ ¼å¼"""
        return {
            "total_validators": self.total_validators,
            "executed_validators": self.executed_validators,
            "skipped_validators": self.skipped_validators,
            "execution_time": self.execution_time,
            "cache_hits": self.cache_hits,
            "cache_misses": self.cache_misses,
            "success_rate": self.get_success_rate()
        }
    
    def get_success_rate(self) -> float:
        """è®¡ç®—æˆåŠŸç‡"""
        if self.executed_validators == 0:
            return 0.0
        return (self.executed_validators - self.skipped_validators) / self.executed_validators

@dataclass
class ValidationResult:
    """éªŒè¯ç»“æœ - åŒ…å«å®Œæ•´çš„éªŒè¯ä¿¡æ¯"""
    
    status: ValidationStatus
    errors: List[ValidationError] = field(default_factory=list)
    warnings: List[ValidationError] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    metrics: ValidationMetrics = field(default_factory=ValidationMetrics)
    
    # éªŒè¯ä¸Šä¸‹æ–‡ä¿¡æ¯
    request_id: Optional[str] = None
    validator_results: Dict[str, ValidationStatus] = field(default_factory=dict)
    execution_order: List[str] = field(default_factory=list)
    
    # æ—¶é—´æˆ³
    start_time: datetime = field(default_factory=datetime.now)
    end_time: Optional[datetime] = None
    
    @property
    def is_valid(self) -> bool:
        """æ˜¯å¦éªŒè¯é€šè¿‡ï¼ˆæˆåŠŸæˆ–ä»…æœ‰è­¦å‘Šï¼‰"""
        return self.status in [ValidationStatus.SUCCESS, ValidationStatus.WARNING]
    
    @property
    def has_errors(self) -> bool:
        """æ˜¯å¦æœ‰é”™è¯¯"""
        return len(self.errors) > 0
    
    @property
    def has_warnings(self) -> bool:
        """æ˜¯å¦æœ‰è­¦å‘Š"""
        return len(self.warnings) > 0
    
    @property
    def has_critical_errors(self) -> bool:
        """æ˜¯å¦æœ‰ä¸¥é‡é”™è¯¯"""
        return any(error.severity == ValidationSeverity.CRITICAL for error in self.errors)
    
    @property
    def execution_time(self) -> float:
        """è·å–æ‰§è¡Œæ—¶é—´ï¼ˆç§’ï¼‰"""
        if self.end_time and self.start_time:
            return (self.end_time - self.start_time).total_seconds()
        return 0.0
    
    def add_error(self, error: ValidationError) -> None:
        """æ·»åŠ é”™è¯¯"""
        self.errors.append(error)
        self._update_status_from_error(error)
    
    def add_warning(self, warning: ValidationError) -> None:
        """æ·»åŠ è­¦å‘Š"""
        self.warnings.append(warning)
        if self.status == ValidationStatus.SUCCESS:
            self.status = ValidationStatus.WARNING
    
    def add_validator_result(self, validator_name: str, status: ValidationStatus) -> None:
        """è®°å½•éªŒè¯å™¨æ‰§è¡Œç»“æœ"""
        self.validator_results[validator_name] = status
        self.execution_order.append(validator_name)
        self.metrics.executed_validators += 1
    
    def _update_status_from_error(self, error: ValidationError) -> None:
        """æ ¹æ®é”™è¯¯æ›´æ–°çŠ¶æ€"""
        if error.severity == ValidationSeverity.CRITICAL:
            self.status = ValidationStatus.CRITICAL
        elif self.status in [ValidationStatus.SUCCESS, ValidationStatus.WARNING]:
            self.status = ValidationStatus.ERROR
    
    def complete(self) -> None:
        """æ ‡è®°éªŒè¯å®Œæˆ"""
        self.end_time = datetime.now()
        self.metrics.execution_time = self.execution_time
    
    def merge(self, other: 'ValidationResult') -> 'ValidationResult':
        """åˆå¹¶éªŒè¯ç»“æœ"""
        # ç¡®å®šåˆå¹¶åçš„çŠ¶æ€
        status_priority = {
            ValidationStatus.CRITICAL: 4,
            ValidationStatus.ERROR: 3,
            ValidationStatus.WARNING: 2,
            ValidationStatus.SUCCESS: 1,
            ValidationStatus.SKIPPED: 0
        }
        
        merged_status = max(
            self.status, other.status, 
            key=lambda x: status_priority[x]
        )
        
        # åˆå¹¶æŒ‡æ ‡
        merged_metrics = ValidationMetrics(
            total_validators=self.metrics.total_validators + other.metrics.total_validators,
            executed_validators=self.metrics.executed_validators + other.metrics.executed_validators,
            skipped_validators=self.metrics.skipped_validators + other.metrics.skipped_validators,
            execution_time=self.metrics.execution_time + other.metrics.execution_time,
            cache_hits=self.metrics.cache_hits + other.metrics.cache_hits,
            cache_misses=self.metrics.cache_misses + other.metrics.cache_misses
        )
        
        merged = ValidationResult(
            status=merged_status,
            errors=self.errors + other.errors,
            warnings=self.warnings + other.warnings,
            metadata={**self.metadata, **other.metadata},
            metrics=merged_metrics,
            request_id=self.request_id or other.request_id,
            validator_results={**self.validator_results, **other.validator_results},
            execution_order=self.execution_order + other.execution_order,
            start_time=min(self.start_time, other.start_time)
        )
        
        return merged
    
    def get_errors_by_severity(self, severity: ValidationSeverity) -> List[ValidationError]:
        """æŒ‰ä¸¥é‡ç¨‹åº¦è·å–é”™è¯¯"""
        return [error for error in self.errors if error.severity == severity]
    
    def get_failed_validators(self) -> List[str]:
        """è·å–å¤±è´¥çš„éªŒè¯å™¨åˆ—è¡¨"""
        return [
            name for name, status in self.validator_results.items()
            if status in [ValidationStatus.ERROR, ValidationStatus.CRITICAL]
        ]
    
    def to_dict(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºå­—å…¸æ ¼å¼"""
        return {
            "status": self.status.value,
            "is_valid": self.is_valid,
            "errors": [error.to_dict() for error in self.errors],
            "warnings": [warning.to_dict() for warning in self.warnings],
            "metadata": self.metadata,
            "metrics": self.metrics.to_dict(),
            "request_id": self.request_id,
            "validator_results": {k: v.value for k, v in self.validator_results.items()},
            "execution_order": self.execution_order,
            "execution_time": self.execution_time,
            "has_critical_errors": self.has_critical_errors
        }
    
    def to_http_response(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºHTTPå“åº”æ ¼å¼"""
        if self.is_valid:
            return {
                "success": True,
                "status": self.status.value,
                "warnings": [warning.to_dict() for warning in self.warnings] if self.warnings else None,
                "metadata": self.metadata if self.metadata else None
            }
        else:
            return {
                "success": False,
                "status": self.status.value,
                "errors": [error.to_dict() for error in self.errors],
                "warnings": [warning.to_dict() for warning in self.warnings] if self.warnings else None,
                "failed_validators": self.get_failed_validators(),
                "request_id": self.request_id
            }
    
    @classmethod
    def create_success(cls, metadata: Optional[Dict[str, Any]] = None) -> 'ValidationResult':
        """åˆ›å»ºæˆåŠŸç»“æœ"""
        return cls(
            status=ValidationStatus.SUCCESS,
            metadata=metadata or {}
        )
    
    @classmethod
    def create_error(cls, error: ValidationError, metadata: Optional[Dict[str, Any]] = None) -> 'ValidationResult':
        """åˆ›å»ºé”™è¯¯ç»“æœ"""
        result = cls(
            status=ValidationStatus.ERROR,
            metadata=metadata or {}
        )
        result.add_error(error)
        return result
```

## ğŸ“‹ é…ç½®æ–‡ä»¶æ›´æ–°

```toml
# settings.toml æ–°å¢éƒ¨åˆ†
[default.validation]
# è¯·æ±‚éªŒè¯å…¨å±€é…ç½®
enabled = true
mode = "strict"  # strict, lenient, fail_fast, continue
max_request_size = 1048576  # 1MB
max_message_length = 10000
enable_rate_limiting = true
requests_per_minute = 60
enable_caching = true
cache_ttl = 300  # 5åˆ†é’Ÿ
enable_metrics = true
enable_streaming_validation = false

# éªŒè¯å™¨ä¼˜å…ˆçº§é…ç½®
[default.validation.priorities]
security = "critical"
format = "high"
content = "medium"
rate_limit = "high"
size = "high"
language = "low"
session = "medium"

# APIç«¯ç‚¹éªŒè¯é“¾é…ç½®
[default.validation.endpoints]
# ä¸»è¦APIç«¯ç‚¹
"/api/chat/agent" = ["security", "rate_limit", "size", "format", "content", "language", "session"]
"/health" = ["size"]
"/api/status" = ["security", "size"]
"/api/mcp/*" = ["security", "rate_limit", "format", "content"]

# éªŒè¯å™¨å…·ä½“é…ç½®
[[default.validation.validators]]
name = "security"
type = "security"
enabled = true
priority = "critical"
[default.validation.validators.config]
enable_xss_protection = true
enable_sql_injection_detection = true
enable_csrf_protection = true
allowed_origins = ["*"]
max_header_size = 8192

[[default.validation.validators]]
name = "rate_limit"
type = "rate_limit"
enabled = true
priority = "high"
[default.validation.validators.config]
requests_per_minute = 60
requests_per_hour = 1000
enable_ip_based_limiting = true
enable_user_based_limiting = true
burst_size = 10

[[default.validation.validators]]
name = "size"
type = "size"
enabled = true
priority = "high"
[default.validation.validators.config]
max_request_size = 1048576
max_content_length = 1048576
max_json_depth = 10
max_array_length = 1000

[[default.validation.validators]]
name = "format"
type = "format"
enabled = true
priority = "high"
[default.validation.validators.config]
require_json_content_type = true
validate_json_syntax = true
validate_required_fields = true
strict_field_types = true

[[default.validation.validators]]
name = "content"
type = "content"
enabled = true
priority = "medium"
[default.validation.validators.config]
max_message_length = 10000
enable_profanity_filter = false
enable_spam_detection = true
max_dialogue_history_length = 50

[[default.validation.validators]]
name = "language"
type = "language"
enabled = true
priority = "low"
[default.validation.validators.config]
supported_languages = ["en", "zh", "es", "fr", "ja"]
auto_detect_language = true
fallback_to_default = true
validate_language_consistency = false

[[default.validation.validators]]
name = "session"
type = "session"
enabled = true
priority = "medium"
[default.validation.validators.config]
validate_session_id_format = true
check_session_expiry = false
require_valid_session = false
max_session_inactivity = 3600  # 1å°æ—¶

# ç¼“å­˜é…ç½®
[default.validation.cache]
enabled = true
backend = "memory"  # memory, redis
default_ttl = 300
max_size = 1000
cleanup_interval = 60

# æŒ‡æ ‡å’Œç›‘æ§é…ç½®
[default.validation.metrics]
enabled = true
include_timing = true
include_success_rate = true
include_error_details = true
export_interval = 60

# æ—¥å¿—é…ç½®
[default.validation.logging]
enabled = true
level = "INFO"
include_request_details = true
include_validation_path = true
include_performance_metrics = true
log_successful_validations = false
log_failed_validations = true

# é”™è¯¯å¤„ç†é…ç½®
[default.validation.error_handling]
include_suggestions = true
include_error_codes = true
include_field_details = true
mask_sensitive_data = true
max_error_message_length = 500

# æµå¼éªŒè¯é…ç½®
[default.validation.streaming]
enabled = false
validate_chunks = true
buffer_size = 1024
timeout = 30
```

---

## ğŸ—ï¸ æ ¸å¿ƒç»„ä»¶è¯¦ç»†è®¾è®¡

### 1. éªŒè¯ç­–ç•¥å®ç°ï¼ˆStrategy Patternï¼‰

```python
# agent/validation/strategies/security_validator.py
from typing import Dict, Any, List, Optional, Pattern
import re
from ..core.interfaces import IValidationStrategy
from ..core.validation_result import ValidationResult, ValidationError, ValidationSeverity

class SecurityValidationStrategy(IValidationStrategy):
    """å®‰å…¨éªŒè¯ç­–ç•¥ - æ£€æµ‹XSSã€SQLæ³¨å…¥ç­‰å®‰å…¨å¨èƒ"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.xss_patterns = self._compile_xss_patterns()
        self.sql_injection_patterns = self._compile_sql_patterns()
        self.sensitive_patterns = self._compile_sensitive_patterns()
    
    def _compile_xss_patterns(self) -> List[Pattern]:
        """ç¼–è¯‘XSSæ£€æµ‹æ¨¡å¼"""
        patterns = [
            r'<script[^>]*>.*?</script>',
            r'javascript:',
            r'on\w+\s*=',
            r'<iframe[^>]*>',
            r'<object[^>]*>',
            r'<embed[^>]*>'
        ]
        return [re.compile(pattern, re.IGNORECASE) for pattern in patterns]
    
    def _compile_sql_patterns(self) -> List[Pattern]:
        """ç¼–è¯‘SQLæ³¨å…¥æ£€æµ‹æ¨¡å¼"""
        patterns = [
            r'\b(union|select|insert|update|delete|drop|create|alter)\b.*\b(from|where|into)\b',
            r'[\'\"]\s*(or|and)\s*[\'\"]\s*=\s*[\'\"]\s*[\'\"]\s*',
            r';\s*(drop|delete|update|insert)',
            r'--\s*',
            r'/\*.*?\*/'
        ]
        return [re.compile(pattern, re.IGNORECASE) for pattern in patterns]
    
    def _compile_sensitive_patterns(self) -> List[Pattern]:
        """ç¼–è¯‘æ•æ„Ÿä¿¡æ¯æ£€æµ‹æ¨¡å¼"""
        patterns = [
            r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',  # Email
            r'\b\d{4}[- ]?\d{4}[- ]?\d{4}[- ]?\d{4}\b',  # ä¿¡ç”¨å¡å·
            r'\b\d{3}-\d{2}-\d{4}\b',  # SSN
            r'\b(?:\d{1,3}\.){3}\d{1,3}\b',  # IPåœ°å€
        ]
        return [re.compile(pattern) for pattern in patterns]
    
    async def execute(self, data: Any, rules: Dict[str, Any]) -> ValidationResult:
        """æ‰§è¡Œå®‰å…¨éªŒè¯"""
        result = ValidationResult.create_success()
        
        if isinstance(data, str):
            content = data
        elif isinstance(data, dict):
            content = str(data)
        else:
            content = str(data)
        
        # XSSæ£€æµ‹
        if self.config.get("enable_xss_protection", True):
            await self._check_xss(content, result)
        
        # SQLæ³¨å…¥æ£€æµ‹
        if self.config.get("enable_sql_injection_detection", True):
            await self._check_sql_injection(content, result)
        
        # æ•æ„Ÿä¿¡æ¯æ£€æµ‹
        if self.config.get("enable_sensitive_data_detection", False):
            await self._check_sensitive_data(content, result)
        
        return result
    
    async def _check_xss(self, content: str, result: ValidationResult) -> None:
        """æ£€æŸ¥XSSæ”»å‡»"""
        for pattern in self.xss_patterns:
            if pattern.search(content):
                error = ValidationError(
                    code="XSS_DETECTED",
                    message="æ£€æµ‹åˆ°æ½œåœ¨çš„XSSæ”»å‡»ä»£ç ",
                    validator="security",
                    severity=ValidationSeverity.CRITICAL,
                    suggestion="è¯·ç§»é™¤HTMLæ ‡ç­¾å’ŒJavaScriptä»£ç "
                )
                result.add_error(error)
                break
    
    async def _check_sql_injection(self, content: str, result: ValidationResult) -> None:
        """æ£€æŸ¥SQLæ³¨å…¥"""
        for pattern in self.sql_injection_patterns:
            if pattern.search(content):
                error = ValidationError(
                    code="SQL_INJECTION_DETECTED",
                    message="æ£€æµ‹åˆ°æ½œåœ¨çš„SQLæ³¨å…¥æ”»å‡»",
                    validator="security",
                    severity=ValidationSeverity.CRITICAL,
                    suggestion="è¯·é¿å…ä½¿ç”¨SQLå…³é”®å­—å’Œç‰¹æ®Šå­—ç¬¦"
                )
                result.add_error(error)
                break
    
    async def _check_sensitive_data(self, content: str, result: ValidationResult) -> None:
        """æ£€æŸ¥æ•æ„Ÿä¿¡æ¯"""
        for pattern in self.sensitive_patterns:
            if pattern.search(content):
                error = ValidationError(
                    code="SENSITIVE_DATA_DETECTED",
                    message="æ£€æµ‹åˆ°å¯èƒ½çš„æ•æ„Ÿä¿¡æ¯",
                    validator="security",
                    severity=ValidationSeverity.HIGH,
                    suggestion="è¯·é¿å…åœ¨è¯·æ±‚ä¸­åŒ…å«æ•æ„Ÿä¸ªäººä¿¡æ¯"
                )
                result.add_warning(error)
                break
    
    def get_strategy_name(self) -> str:
        return "security"
```

### 2. éªŒè¯é“¾å®ç°ï¼ˆChain of Responsibility Patternï¼‰

```python
# agent/validation/chains/async_validation_chain.py
import asyncio
from typing import List, Dict, Any, Optional
from ..core.interfaces import IValidator, IValidationChain
from ..core.validation_context import ValidationContext, ValidationMode
from ..core.validation_result import ValidationResult, ValidationStatus
from ..utils.validation_utils import ValidationTimer

class AsyncValidationChain(IValidationChain):
    """å¼‚æ­¥éªŒè¯é“¾ - æ”¯æŒå¹¶è¡Œå’Œä¸²è¡Œæ‰§è¡Œ"""
    
    def __init__(self, name: str = "default"):
        self.name = name
        self.validators: List[IValidator] = []
        self.parallel_groups: Dict[str, List[IValidator]] = {}
        
    def add_validator(self, validator: IValidator) -> 'AsyncValidationChain':
        """æ·»åŠ éªŒè¯å™¨åˆ°é“¾ä¸­"""
        if validator not in self.validators:
            self.validators.append(validator)
            # æŒ‰ä¼˜å…ˆçº§æ’åº
            self.validators.sort(key=lambda v: v.get_priority().value)
        return self
    
    def remove_validator(self, validator_name: str) -> 'AsyncValidationChain':
        """ä»é“¾ä¸­ç§»é™¤éªŒè¯å™¨"""
        self.validators = [v for v in self.validators if v.get_validator_name() != validator_name]
        return self
    
    def add_parallel_group(self, group_name: str, validators: List[IValidator]) -> 'AsyncValidationChain':
        """æ·»åŠ å¹¶è¡Œæ‰§è¡Œç»„"""
        self.parallel_groups[group_name] = validators
        return self
    
    async def validate(self, context: ValidationContext) -> ValidationResult:
        """ä¸²è¡Œæ‰§è¡ŒéªŒè¯é“¾"""
        result = ValidationResult.create_success()
        result.request_id = context.request_id
        
        with ValidationTimer() as timer:
            for validator in self.validators:
                if context.should_skip_validator(validator.get_validator_name()):
                    result.add_validator_result(validator.get_validator_name(), ValidationStatus.SKIPPED)
                    result.metrics.skipped_validators += 1
                    continue
                
                context.add_to_path(validator.get_validator_name())
                
                try:
                    validator_result = await validator.validate(context)
                    result = result.merge(validator_result)
                    result.add_validator_result(validator.get_validator_name(), validator_result.status)
                    
                    # å¿«é€Ÿå¤±è´¥æ¨¡å¼
                    if (context.validation_mode == ValidationMode.FAIL_FAST and 
                        not validator_result.is_valid):
                        break
                        
                except Exception as e:
                    error = ValidationError(
                        code="VALIDATOR_ERROR",
                        message=f"éªŒè¯å™¨ {validator.get_validator_name()} æ‰§è¡Œå¤±è´¥: {str(e)}",
                        validator=validator.get_validator_name(),
                        severity=ValidationSeverity.HIGH
                    )
                    result.add_error(error)
                    result.add_validator_result(validator.get_validator_name(), ValidationStatus.ERROR)
        
        result.metrics.execution_time = timer.elapsed_time
        result.complete()
        return result
    
    async def validate_parallel(self, context: ValidationContext) -> ValidationResult:
        """å¹¶è¡Œæ‰§è¡ŒéªŒè¯é“¾"""
        result = ValidationResult.create_success()
        result.request_id = context.request_id
        
        with ValidationTimer() as timer:
            # åˆ›å»ºéªŒè¯ä»»åŠ¡
            tasks = []
            for validator in self.validators:
                if context.should_skip_validator(validator.get_validator_name()):
                    result.add_validator_result(validator.get_validator_name(), ValidationStatus.SKIPPED)
                    result.metrics.skipped_validators += 1
                    continue
                
                task = self._create_validation_task(validator, context)
                tasks.append(task)
            
            # å¹¶è¡Œæ‰§è¡Œ
            if tasks:
                validator_results = await asyncio.gather(*tasks, return_exceptions=True)
                
                for i, validator_result in enumerate(validator_results):
                    validator = self.validators[i]
                    validator_name = validator.get_validator_name()
                    
                    if isinstance(validator_result, Exception):
                        error = ValidationError(
                            code="VALIDATOR_ERROR",
                            message=f"éªŒè¯å™¨ {validator_name} æ‰§è¡Œå¤±è´¥: {str(validator_result)}",
                            validator=validator_name,
                            severity=ValidationSeverity.HIGH
                        )
                        result.add_error(error)
                        result.add_validator_result(validator_name, ValidationStatus.ERROR)
                    else:
                        result = result.merge(validator_result)
                        result.add_validator_result(validator_name, validator_result.status)
        
        result.metrics.execution_time = timer.elapsed_time
        result.complete()
        return result
    
    async def _create_validation_task(self, validator: IValidator, context: ValidationContext):
        """åˆ›å»ºéªŒè¯ä»»åŠ¡"""
        try:
            return await validator.validate(context)
        except Exception as e:
            return ValidationResult.create_error(
                ValidationError(
                    code="VALIDATOR_EXCEPTION",
                    message=str(e),
                    validator=validator.get_validator_name(),
                    severity=ValidationSeverity.HIGH
                )
            )
```

### 3. ä¸­é—´ä»¶é›†æˆï¼ˆMiddleware Patternï¼‰

```python
# agent/validation/middleware/validation_middleware.py
import time
from typing import Dict, Any, Optional, Callable
from fastapi import Request, Response, HTTPException
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import JSONResponse

from ..core.validation_context import ValidationContext, ValidationMode
from ..factories.chain_factory import ValidationChainFactory
from ..config.validation_config import ValidationConfig
from ..observers.logging_observer import LoggingObserver
from ..observers.metrics_observer import MetricsObserver
from ..observers.streaming_observer import StreamingObserver
from ..utils.error_formatters import ErrorFormatter

class ValidationMiddleware(BaseHTTPMiddleware):
    """è¯·æ±‚éªŒè¯ä¸­é—´ä»¶ - ç»Ÿä¸€å¤„ç†æ‰€æœ‰è¯·æ±‚éªŒè¯"""
    
    def __init__(self, app, config: ValidationConfig):
        super().__init__(app)
        self.config = config
        self.chain_factory = ValidationChainFactory(config)
        self.error_formatter = ErrorFormatter(config)
        
        # åˆå§‹åŒ–è§‚å¯Ÿè€…
        self.observers = []
        if config.logging.enabled:
            self.observers.append(LoggingObserver(config.logging))
        if config.metrics.enabled:
            self.observers.append(MetricsObserver(config.metrics))
    
    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        """å¤„ç†è¯·æ±‚éªŒè¯"""
        # æ£€æŸ¥æ˜¯å¦éœ€è¦éªŒè¯
        if not self._should_validate(request):
            return await call_next(request)
        
        start_time = time.time()
        
        try:
            # åˆ›å»ºéªŒè¯ä¸Šä¸‹æ–‡
            context = await self._create_validation_context(request)
            
            # è·å–éªŒè¯é“¾
            validation_chain = self.chain_factory.create_chain_for_endpoint(
                request.url.path
            )
            
            # æ·»åŠ æµå¼éªŒè¯è§‚å¯Ÿè€…
            if context.is_streaming_request():
                streaming_observer = StreamingObserver(context.streaming_session)
                self.observers.append(streaming_observer)
            
            # é€šçŸ¥éªŒè¯å¼€å§‹
            for observer in self.observers:
                await observer.on_validation_start(context)
            
            # æ‰§è¡ŒéªŒè¯
            if self.config.enable_parallel_validation:
                result = await validation_chain.validate_parallel(context)
            else:
                result = await validation_chain.validate(context)
            
            # é€šçŸ¥éªŒè¯å®Œæˆ
            for observer in self.observers:
                await observer.on_validation_complete(result)
            
            # æ£€æŸ¥éªŒè¯ç»“æœ
            if not result.is_valid:
                return await self._handle_validation_failure(result, context)
            
            # å°†éªŒè¯ç»“æœæ·»åŠ åˆ°è¯·æ±‚çŠ¶æ€
            request.state.validation_result = result
            request.state.validation_context = context
            
            # ç»§ç»­å¤„ç†è¯·æ±‚
            response = await call_next(request)
            
            # è®°å½•æˆåŠŸæŒ‡æ ‡
            execution_time = time.time() - start_time
            await self._record_success_metrics(context, execution_time)
            
            return response
            
        except Exception as e:
            # é€šçŸ¥éªŒè¯é”™è¯¯
            for observer in self.observers:
                await observer.on_validation_error(e, context if 'context' in locals() else None)
            
            # è®°å½•é”™è¯¯æŒ‡æ ‡
            execution_time = time.time() - start_time
            await self._record_error_metrics(request.url.path, str(e), execution_time)
            
            # è¿”å›å†…éƒ¨é”™è¯¯
            return JSONResponse(
                status_code=500,
                content={"error": "Internal validation error", "request_id": getattr(context, 'request_id', 'unknown')}
            )
    
    def _should_validate(self, request: Request) -> bool:
        """åˆ¤æ–­æ˜¯å¦éœ€è¦éªŒè¯è¯·æ±‚"""
        if not self.config.enabled:
            return False
        
        path = request.url.path
        method = request.method
        
        # æ£€æŸ¥æ’é™¤è·¯å¾„
        for excluded_path in self.config.excluded_paths:
            if path.startswith(excluded_path):
                return False
        
        # æ£€æŸ¥åŒ…å«è·¯å¾„
        if self.config.included_paths:
            return any(path.startswith(included) for included in self.config.included_paths)
        
        # é»˜è®¤éªŒè¯APIç«¯ç‚¹
        return path.startswith('/api/')
    
    async def _create_validation_context(self, request: Request) -> ValidationContext:
        """åˆ›å»ºéªŒè¯ä¸Šä¸‹æ–‡"""
        # è¯»å–è¯·æ±‚ä½“
        request_data = None
        if request.method in ['POST', 'PUT', 'PATCH']:
            try:
                request_data = await request.json()
            except:
                request_data = await request.body()
        
        # æ£€æµ‹æµå¼ä¼šè¯
        streaming_session = None
        if hasattr(request.state, 'streaming_session'):
            streaming_session = request.state.streaming_session
        
        context = ValidationContext(
            request=request,
            request_data=request_data,
            validation_mode=ValidationMode(self.config.mode),
            enable_cache=self.config.cache.enabled,
            cache_ttl=self.config.cache.default_ttl,
            streaming_session=streaming_session,
            enable_streaming_validation=self.config.streaming.enabled
        )
        
        return context
    
    async def _handle_validation_failure(
        self, 
        result: ValidationResult, 
        context: ValidationContext
    ) -> JSONResponse:
        """å¤„ç†éªŒè¯å¤±è´¥"""
        # æ ¼å¼åŒ–é”™è¯¯å“åº”
        error_response = self.error_formatter.format_response(result, context)
        
        # ç¡®å®šHTTPçŠ¶æ€ç 
        if result.has_critical_errors:
            status_code = 403  # Forbidden
        elif any(error.code.startswith('RATE_LIMIT') for error in result.errors):
            status_code = 429  # Too Many Requests
        elif any(error.code.startswith('SIZE') for error in result.errors):
            status_code = 413  # Payload Too Large
        else:
            status_code = 400  # Bad Request
        
        return JSONResponse(
            status_code=status_code,
            content=error_response
        )
    
    async def _record_success_metrics(self, context: ValidationContext, execution_time: float):
        """è®°å½•æˆåŠŸæŒ‡æ ‡"""
        for observer in self.observers:
            if hasattr(observer, 'record_success'):
                await observer.record_success(context, execution_time)
    
    async def _record_error_metrics(self, path: str, error: str, execution_time: float):
        """è®°å½•é”™è¯¯æŒ‡æ ‡"""
        for observer in self.observers:
            if hasattr(observer, 'record_error'):
                await observer.record_error(path, error, execution_time)
```

### 4. æµå¼éªŒè¯é›†æˆ

```python
# agent/validation/observers/streaming_observer.py
from typing import Optional
from ..core.interfaces import IValidationObserver
from ..core.validation_context import ValidationContext
from ..core.validation_result import ValidationResult
from ...streaming.stream_types import StreamEvent, StreamEventType
from ...streaming.event_helpers import StreamEventBuilder

class StreamingObserver(IValidationObserver):
    """æµå¼éªŒè¯è§‚å¯Ÿè€… - å°†éªŒè¯äº‹ä»¶å‘é€åˆ°æµå¼ä¼šè¯"""
    
    def __init__(self, streaming_session):
        self.streaming_session = streaming_session
    
    async def on_validation_start(self, context: ValidationContext) -> None:
        """éªŒè¯å¼€å§‹äº‹ä»¶"""
        if not self.streaming_session:
            return
        
        event = StreamEventBuilder.create_custom_event(
            session_id=context.session_id,
            event_type="validation_start",
            data={
                "request_id": context.request_id,
                "validation_mode": context.validation_mode.value,
                "endpoint": context.request_path,
                "validators_count": len(context.enabled_validators) if context.enabled_validators else 0
            }
        )
        
        await self.streaming_session.emit_event(event)
    
    async def on_validation_step(self, validator_name: str, result: ValidationResult) -> None:
        """éªŒè¯æ­¥éª¤å®Œæˆäº‹ä»¶"""
        if not self.streaming_session:
            return
        
        event = StreamEventBuilder.create_custom_event(
            session_id=self.streaming_session.session_id,
            event_type="validation_step",
            data={
                "validator": validator_name,
                "status": result.status.value,
                "has_errors": result.has_errors,
                "has_warnings": result.has_warnings,
                "execution_time": result.execution_time
            }
        )
        
        await self.streaming_session.emit_event(event)
    
    async def on_validation_complete(self, result: ValidationResult) -> None:
        """éªŒè¯å®Œæˆäº‹ä»¶"""
        if not self.streaming_session:
            return
        
        event = StreamEventBuilder.create_custom_event(
            session_id=self.streaming_session.session_id,
            event_type="validation_complete",
            data={
                "status": result.status.value,
                "is_valid": result.is_valid,
                "errors_count": len(result.errors),
                "warnings_count": len(result.warnings),
                "execution_time": result.execution_time,
                "metrics": result.metrics.to_dict()
            }
        )
        
        await self.streaming_session.emit_event(event)
    
    async def on_validation_error(self, error: Exception, context: Optional[ValidationContext] = None) -> None:
        """éªŒè¯é”™è¯¯äº‹ä»¶"""
        if not self.streaming_session:
            return
        
        event = StreamEventBuilder.error(
            session_id=self.streaming_session.session_id,
            error_message=f"éªŒè¯ç³»ç»Ÿé”™è¯¯: {str(error)}",
            metadata={
                "error_type": type(error).__name__,
                "request_id": context.request_id if context else None,
                "validator": context.current_validator if context else None
            }
        )
        
        await self.streaming_session.emit_event(event)
```

---

## ğŸ¯ è®¾è®¡åŸåˆ™ä½“ç°

### 1. SOLIDåŸåˆ™ä½“ç°
- **å•ä¸€èŒè´£åŸåˆ™**ï¼šæ¯ä¸ªéªŒè¯å™¨åªè´Ÿè´£ä¸€ç§éªŒè¯é€»è¾‘ï¼Œæ¯ä¸ªè§‚å¯Ÿè€…åªå¤„ç†ä¸€ç±»äº‹ä»¶
- **å¼€é—­åŸåˆ™**ï¼šé€šè¿‡æ¥å£å’ŒæŠ½è±¡ç±»æ”¯æŒæ–°éªŒè¯å™¨æ‰©å±•ï¼Œæ— éœ€ä¿®æ”¹ç°æœ‰ä»£ç 
- **é‡Œæ°æ›¿æ¢åŸåˆ™**ï¼šæ‰€æœ‰éªŒè¯å™¨å®ç°éƒ½å¯ä»¥æ›¿æ¢åŸºç±»ï¼Œæ‰€æœ‰è§‚å¯Ÿè€…éƒ½å¯ä»¥æ›¿æ¢åŸºæ¥å£
- **æ¥å£éš”ç¦»åŸåˆ™**ï¼šå®šä¹‰äº†ç»†ç²’åº¦çš„ä¸“ç”¨æ¥å£ï¼ˆIValidatorã€IValidationChainã€IValidationObserverç­‰ï¼‰
- **ä¾èµ–å€’ç½®åŸåˆ™**ï¼šé«˜å±‚æ¨¡å—ï¼ˆä¸­é—´ä»¶ã€é“¾ï¼‰ä¾èµ–æŠ½è±¡æ¥å£è€Œéå…·ä½“éªŒè¯å™¨å®ç°

### 2. ç°ä»£æ¶æ„åŸåˆ™
- **å¾®æœåŠ¡åŒ–**ï¼šéªŒè¯ç³»ç»Ÿä½œä¸ºç‹¬ç«‹æ¨¡å—ï¼Œä¸ä¸»ä¸šåŠ¡é€»è¾‘è§£è€¦
- **äº‘åŸç”Ÿ**ï¼šæ”¯æŒå®¹å™¨åŒ–éƒ¨ç½²ï¼Œæ— çŠ¶æ€è®¾è®¡ä¾¿äºæ°´å¹³æ‰©å±•
- **å“åº”å¼**ï¼šæ”¯æŒæµå¼éªŒè¯å’Œå¼‚æ­¥å¤„ç†ï¼Œä¸é˜»å¡ä¸»ä¸šåŠ¡æµç¨‹
- **å¯è§‚æµ‹æ€§**ï¼šå®Œæ•´çš„æ—¥å¿—ã€ç›‘æ§å’Œè¿½è¸ªç³»ç»Ÿï¼Œæ”¯æŒé—®é¢˜è¯Šæ–­
- **å®‰å…¨ç¬¬ä¸€**ï¼šå†…ç½®å¤šå±‚å®‰å…¨éªŒè¯æœºåˆ¶å’Œæœ€ä½³å®è·µ

### 3. ä¸GTPlannerç°æœ‰ç³»ç»Ÿçš„å®Œç¾é›†æˆ

#### 3.1 æ—¥å¿—ç³»ç»Ÿé›†æˆ
```python
# ä½¿ç”¨ç°æœ‰çš„æ—¥å¿—é…ç½®ç³»ç»Ÿ
from utils.logger_config import get_logger

class ValidationLogger:
    def __init__(self):
        self.logger = get_logger("validation")
    
    async def log_validation_result(self, context: ValidationContext, result: ValidationResult):
        if result.is_valid:
            self.logger.info(f"éªŒè¯æˆåŠŸ - è¯·æ±‚ID: {context.request_id}, æ‰§è¡Œæ—¶é—´: {result.execution_time:.3f}s")
        else:
            self.logger.warning(f"éªŒè¯å¤±è´¥ - è¯·æ±‚ID: {context.request_id}, é”™è¯¯æ•°: {len(result.errors)}")
```

#### 3.2 å¤šè¯­è¨€ç³»ç»Ÿé›†æˆ
```python
# é›†æˆç°æœ‰çš„å¤šè¯­è¨€ç®¡ç†å™¨
from utils.multilingual_utils import MultilingualManager

class LanguageValidationStrategy(IValidationStrategy):
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.multilingual_manager = MultilingualManager()
    
    async def execute(self, data: Any, rules: Dict[str, Any]) -> ValidationResult:
        # ä½¿ç”¨ç°æœ‰è¯­è¨€æ£€æµ‹åŠŸèƒ½
        detected_language = self.multilingual_manager.determine_language(str(data))
        
        # éªŒè¯è¯­è¨€æ”¯æŒ
        if detected_language not in self.config.get("supported_languages", []):
            error = ValidationError(
                code="UNSUPPORTED_LANGUAGE",
                message=f"ä¸æ”¯æŒçš„è¯­è¨€: {detected_language}",
                validator="language",
                severity=ValidationSeverity.MEDIUM
            )
            return ValidationResult.create_error(error)
        
        return ValidationResult.create_success({"detected_language": detected_language})
```

#### 3.3 æµå¼å“åº”ç³»ç»Ÿé›†æˆ
```python
# ä¸ç°æœ‰SSEç³»ç»Ÿæ— ç¼é›†æˆ
class ValidationAwareSSEHandler(SSEGTPlanner):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.validation_observers = []
    
    async def process_request_stream(self, agent_context: Dict[str, Any], **kwargs):
        # åœ¨æµå¼ä¼šè¯ä¸­æ·»åŠ éªŒè¯è§‚å¯Ÿè€…
        if self.sse_handler and hasattr(self.sse_handler, 'streaming_session'):
            validation_observer = StreamingObserver(self.sse_handler.streaming_session)
            self.validation_observers.append(validation_observer)
        
        return await super().process_request_stream(agent_context, **kwargs)
```

#### 3.4 é…ç½®ç³»ç»Ÿé›†æˆ
```python
# æ‰©å±•ç°æœ‰çš„é…ç½®ç®¡ç†
from utils.config_manager import MultilingualConfig

class ValidationConfig(MultilingualConfig):
    def __init__(self, settings_file: str = "settings.toml"):
        super().__init__(settings_file)
        self.validation_settings = self._load_validation_config()
    
    def _load_validation_config(self) -> Dict[str, Any]:
        return {
            "enabled": self._settings.get("validation.enabled", True),
            "mode": self._settings.get("validation.mode", "strict"),
            "validators": self._settings.get("validation.validators", []),
            "endpoints": self._settings.get("validation.endpoints", {}),
            "cache": self._settings.get("validation.cache", {}),
            "metrics": self._settings.get("validation.metrics", {})
        }
```

## ğŸš€ éƒ¨ç½²å’Œé›†æˆæŒ‡å—

### 1. FastAPIåº”ç”¨é›†æˆ

```python
# fastapi_main.py é›†æˆç¤ºä¾‹
from agent.validation.middleware.validation_middleware import ValidationMiddleware
from agent.validation.config.validation_config import ValidationConfig
from agent.validation.factories.validator_factory import ValidatorFactory

# åˆ›å»ºFastAPIåº”ç”¨
app = FastAPI(title="GTPlanner API")

# åŠ è½½éªŒè¯é…ç½®
validation_config = ValidationConfig("settings.toml")

# æ³¨å†ŒéªŒè¯å™¨
validator_factory = ValidatorFactory(validation_config)
validator_factory.register_default_validators()

# æ·»åŠ éªŒè¯ä¸­é—´ä»¶ï¼ˆåœ¨CORSä¸­é—´ä»¶ä¹‹åï¼‰
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.add_middleware(ValidationMiddleware, config=validation_config)
```

### 2. æ¸è¿›å¼éƒ¨ç½²ç­–ç•¥

#### é˜¶æ®µ1ï¼šåŸºç¡€éªŒè¯ï¼ˆ1-2å‘¨ï¼‰
- å®ç°æ ¸å¿ƒæ¥å£å’ŒåŸºç¡€éªŒè¯å™¨
- é›†æˆå®‰å…¨éªŒè¯å’Œå¤§å°éªŒè¯
- éƒ¨ç½²åˆ°å¼€å‘ç¯å¢ƒæµ‹è¯•

#### é˜¶æ®µ2ï¼šå®Œæ•´åŠŸèƒ½ï¼ˆ2-3å‘¨ï¼‰
- å®ç°æ‰€æœ‰éªŒè¯ç­–ç•¥
- é›†æˆæµå¼å“åº”æ”¯æŒ
- æ·»åŠ ç¼“å­˜å’ŒæŒ‡æ ‡æ”¶é›†

#### é˜¶æ®µ3ï¼šæ€§èƒ½ä¼˜åŒ–ï¼ˆ1å‘¨ï¼‰
- å¹¶è¡ŒéªŒè¯ä¼˜åŒ–
- ç¼“å­˜ç­–ç•¥è°ƒä¼˜
- ç›‘æ§å’Œå‘Šè­¦é…ç½®

### 3. æ€§èƒ½æŒ‡æ ‡

#### é¢„æœŸæ€§èƒ½æŒ‡æ ‡
- **éªŒè¯å»¶è¿Ÿ**: < 50ms (90th percentile)
- **å†…å­˜å ç”¨**: < 100MB (åŒ…å«ç¼“å­˜)
- **CPUä½¿ç”¨ç‡**: < 10% (æ­£å¸¸è´Ÿè½½)
- **ååé‡**: > 1000 requests/second

#### ç›‘æ§æŒ‡æ ‡
- éªŒè¯æˆåŠŸç‡
- å„éªŒè¯å™¨æ‰§è¡Œæ—¶é—´
- ç¼“å­˜å‘½ä¸­ç‡
- é”™è¯¯ç±»å‹åˆ†å¸ƒ

## ğŸ”§ å¼€å‘å’Œæµ‹è¯•æŒ‡å—

### 1. å•å…ƒæµ‹è¯•ç¤ºä¾‹

```python
# tests/validation/test_security_validator.py
import pytest
from agent.validation.strategies.security_validator import SecurityValidationStrategy
from agent.validation.core.validation_result import ValidationStatus

@pytest.mark.asyncio
async def test_xss_detection():
    config = {"enable_xss_protection": True}
    validator = SecurityValidationStrategy(config)
    
    # æµ‹è¯•XSSæ”»å‡»æ£€æµ‹
    malicious_input = "<script>alert('xss')</script>"
    result = await validator.execute(malicious_input, {})
    
    assert result.status == ValidationStatus.ERROR
    assert any(error.code == "XSS_DETECTED" for error in result.errors)

@pytest.mark.asyncio
async def test_safe_content():
    config = {"enable_xss_protection": True}
    validator = SecurityValidationStrategy(config)
    
    # æµ‹è¯•å®‰å…¨å†…å®¹
    safe_input = "è¿™æ˜¯ä¸€ä¸ªå®‰å…¨çš„ç”¨æˆ·è¾“å…¥"
    result = await validator.execute(safe_input, {})
    
    assert result.status == ValidationStatus.SUCCESS
    assert len(result.errors) == 0
```

### 2. é›†æˆæµ‹è¯•ç¤ºä¾‹

```python
# tests/integration/test_validation_middleware.py
import pytest
from fastapi.testclient import TestClient
from fastapi_main import app

client = TestClient(app)

def test_api_validation_success():
    """æµ‹è¯•æ­£å¸¸è¯·æ±‚é€šè¿‡éªŒè¯"""
    response = client.post("/api/chat/agent", json={
        "session_id": "test_session",
        "dialogue_history": [
            {"role": "user", "content": "Hello, world!"}
        ],
        "tool_execution_results": {},
        "session_metadata": {}
    })
    
    assert response.status_code == 200

def test_api_validation_failure():
    """æµ‹è¯•æ¶æ„è¯·æ±‚è¢«æ‹¦æˆª"""
    response = client.post("/api/chat/agent", json={
        "session_id": "test_session",
        "dialogue_history": [
            {"role": "user", "content": "<script>alert('xss')</script>"}
        ],
        "tool_execution_results": {},
        "session_metadata": {}
    })
    
    assert response.status_code == 403
    assert "XSS_DETECTED" in response.json()["errors"][0]["code"]
```

## ğŸ“Š æ€»ç»“

è¿™ä¸ªå®Œæ•´çš„è¯·æ±‚éªŒè¯ç³»ç»Ÿæ¶æ„è®¾è®¡å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

### ğŸ¯ æ ¸å¿ƒä¼˜åŠ¿
1. **æ¨¡å—åŒ–è®¾è®¡**ï¼šæ¸…æ™°çš„èŒè´£åˆ†ç¦»ï¼Œæ˜“äºç»´æŠ¤å’Œæ‰©å±•
2. **é«˜æ€§èƒ½**ï¼šæ”¯æŒå¹¶è¡ŒéªŒè¯å’Œæ™ºèƒ½ç¼“å­˜
3. **å®Œæ•´é›†æˆ**ï¼šä¸GTPlannerç°æœ‰ç³»ç»Ÿæ— ç¼é›†æˆ
4. **æµå¼æ”¯æŒ**ï¼šåŸç”Ÿæ”¯æŒSSEæµå¼å“åº”éªŒè¯
5. **å¯è§‚æµ‹æ€§**ï¼šå®Œæ•´çš„ç›‘æ§ã€æ—¥å¿—å’ŒæŒ‡æ ‡ä½“ç³»
6. **å®‰å…¨ç¬¬ä¸€**ï¼šå¤šå±‚å®‰å…¨é˜²æŠ¤æœºåˆ¶

### ğŸ”„ æ‰©å±•èƒ½åŠ›
- æ”¯æŒæ–°éªŒè¯å™¨çš„çƒ­æ’æ‹”
- æ”¯æŒè‡ªå®šä¹‰éªŒè¯è§„åˆ™
- æ”¯æŒå¤šç§éƒ¨ç½²æ¨¡å¼
- æ”¯æŒæ€§èƒ½ç›‘æ§å’Œè°ƒä¼˜

### ğŸ›¡ï¸ å¯é æ€§ä¿è¯
- å®Œæ•´çš„é”™è¯¯å¤„ç†æœºåˆ¶
- ä¼˜é›…çš„é™çº§ç­–ç•¥
- å…¨é¢çš„æµ‹è¯•è¦†ç›–
- ç”Ÿäº§ç¯å¢ƒéªŒè¯

è¿™ä¸ªæ¶æ„è®¾è®¡ä¸ºGTPlanneræä¾›äº†ä¼ä¸šçº§çš„è¯·æ±‚éªŒè¯èƒ½åŠ›ï¼Œç¡®ä¿ç³»ç»Ÿå®‰å…¨ã€ç¨³å®šã€é«˜æ•ˆè¿è¡Œï¼ŒåŒæ—¶ä¿æŒäº†è‰¯å¥½çš„å¯æ‰©å±•æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚
